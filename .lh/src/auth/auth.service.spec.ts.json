{
    "sourceFile": "src/auth/auth.service.spec.ts",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 2,
            "patches": [
                {
                    "date": 1707879020160,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1707880127403,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,12 +1,12 @@\n import { ConflictException, UnauthorizedException } from '@nestjs/common';\n import { JwtService } from '@nestjs/jwt';\n-import { getModelToken } from '@nestjs/mongoose';\n+import { getModelToken, Schema } from '@nestjs/mongoose';\n import { Test, TestingModule } from '@nestjs/testing';\n import * as bcrypt from 'bcryptjs';\n-import { Model } from 'mongoose';\n+import mongoose, { Model, Document } from 'mongoose';\n import { AuthService } from './auth.service';\n-import { User } from './schemas/user.schema';\n+import { User, UserSchema } from './schemas/user.schema';\n \n describe('AuthService', () => {\n   let authService: AuthService;\n   let model: Model<User>;\n@@ -56,9 +56,11 @@\n     it('should register the new user', async () => {\n       jest.spyOn(bcrypt, 'hash').mockResolvedValue('hashedPassword');\n       jest\n         .spyOn(model, 'create')\n-        .mockImplementationOnce(() => Promise.resolve(mockUser));\n+        .mockImplementationOnce(() =>\n+          Promise.resolve(new mongoose.Document(mockUser, UserModel.Schema)),\n+        );\n \n       jest.spyOn(jwtService, 'sign').mockReturnValue('jwtToken');\n \n       const result = await authService.signUp(signUpDto);\n"
                },
                {
                    "date": 1707881020416,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -0,0 +1,115 @@\n+import { Test, TestingModule } from '@nestjs/testing';\n+import { getModelToken } from '@nestjs/mongoose';\n+import mongoose, { Model } from 'mongoose';\n+import { AuthService } from './auth.service';\n+import { User } from './schemas/user.schema';\n+import { JwtService } from '@nestjs/jwt';\n+import * as bcrypt from 'bcryptjs';\n+import { ConflictException, UnauthorizedException } from '@nestjs/common';\n+\n+describe('AuthService', () => {\n+  let authService: AuthService;\n+  let model: Model<User>;\n+  let jwtService: JwtService;\n+\n+  const mockUser = {\n+    _id: '61c0ccf11d7bf83d153d7c06',\n+    name: 'Ghulam',\n+    email: 'ghulam1@gmail.com',\n+  };\n+\n+  let token = 'jwtToken';\n+\n+  const mockAuthService = {\n+    create: jest.fn(),\n+    findOne: jest.fn(),\n+  };\n+\n+  beforeEach(async () => {\n+    const module: TestingModule = await Test.createTestingModule({\n+      providers: [\n+        AuthService,\n+        JwtService,\n+        {\n+          provide: getModelToken(User.name),\n+          useValue: mockAuthService,\n+        },\n+      ],\n+    }).compile();\n+\n+    authService = module.get<AuthService>(AuthService);\n+    model = module.get<Model<User>>(getModelToken(User.name));\n+    jwtService = module.get<JwtService>(JwtService);\n+  });\n+\n+  it('should be defined', () => {\n+    expect(authService).toBeDefined();\n+  });\n+\n+  describe('signUp', () => {\n+    const signUpDto = {\n+      name: 'Ghulam',\n+      email: 'ghulam1@gmail.com',\n+      password: '12345678',\n+    };\n+\n+    it('should register the new user', async () => {\n+      jest.spyOn(bcrypt, 'hash').mockResolvedValue('hashedPassword');\n+      jest\n+        .spyOn(model, 'create')\n+        .mockImplementationOnce(() => Promise.resolve(mockUser));\n+\n+      jest.spyOn(jwtService, 'sign').mockReturnValue('jwtToken');\n+\n+      const result = await authService.signUp(signUpDto);\n+\n+      expect(bcrypt.hash).toHaveBeenCalled();\n+      expect(result).toEqual({ token });\n+    });\n+\n+    it('should throw duplicate email entered', async () => {\n+      jest\n+        .spyOn(model, 'create')\n+        .mockImplementationOnce(() => Promise.reject({ code: 11000 }));\n+\n+      await expect(authService.signUp(signUpDto)).rejects.toThrow(\n+        ConflictException,\n+      );\n+    });\n+  });\n+\n+  describe('logIn', () => {\n+    const loginDto = {\n+      email: 'ghulam1@gmail.com',\n+      password: '12345678',\n+    };\n+\n+    it('should login user and return the token', async () => {\n+      jest.spyOn(model, 'findOne').mockResolvedValueOnce(mockUser);\n+\n+      jest.spyOn(bcrypt, 'compare').mockResolvedValueOnce(true);\n+      jest.spyOn(jwtService, 'sign').mockReturnValue(token);\n+\n+      const result = await authService.login(loginDto);\n+\n+      expect(result).toEqual({ token });\n+    });\n+\n+    it('should throw invalid email error', async () => {\n+      jest.spyOn(model, 'findOne').mockResolvedValueOnce(null);\n+\n+      expect(authService.login(loginDto)).rejects.toThrow(\n+        UnauthorizedException,\n+      );\n+    });\n+\n+    it('should throw invalid password error', async () => {\n+      jest.spyOn(model, 'findOne').mockResolvedValueOnce(mockUser);\n+      jest.spyOn(bcrypt, 'compare').mockResolvedValueOnce(false);\n+\n+      expect(authService.login(loginDto)).rejects.toThrow(\n+        UnauthorizedException,\n+      );\n+    });\n+  });\n+});\n"
                }
            ],
            "date": 1707879020160,
            "name": "Commit-0",
            "content": "import { Test, TestingModule } from '@nestjs/testing';\nimport { getModelToken } from '@nestjs/mongoose';\nimport mongoose, { Model } from 'mongoose';\nimport { AuthService } from './auth.service';\nimport { User } from './schemas/user.schema';\nimport { JwtService } from '@nestjs/jwt';\nimport * as bcrypt from 'bcryptjs';\nimport { ConflictException, UnauthorizedException } from '@nestjs/common';\n\ndescribe('AuthService', () => {\n  let authService: AuthService;\n  let model: Model<User>;\n  let jwtService: JwtService;\n\n  const mockUser = {\n    _id: '61c0ccf11d7bf83d153d7c06',\n    name: 'Ghulam',\n    email: 'ghulam1@gmail.com',\n  };\n\n  const token = 'jwtToken';\n\n  const mockAuthService = {\n    create: jest.fn(),\n    findOne: jest.fn(),\n  };\n\n  beforeEach(async () => {\n    const module: TestingModule = await Test.createTestingModule({\n      providers: [\n        AuthService,\n        JwtService,\n        {\n          provide: getModelToken(User.name),\n          useValue: mockAuthService,\n        },\n      ],\n    }).compile();\n\n    authService = module.get<AuthService>(AuthService);\n    model = module.get<Model<User>>(getModelToken(User.name));\n    jwtService = module.get<JwtService>(JwtService);\n  });\n\n  it('should be defined', () => {\n    expect(authService).toBeDefined();\n  });\n\n  describe('signUp', () => {\n    const signUpDto = {\n      name: 'Ghulam',\n      email: 'ghulam1@gmail.com',\n      password: '12345678',\n    };\n\n    it('should register the new user', async () => {\n      jest.spyOn(bcrypt, 'hash').mockResolvedValue('hashedPassword');\n      jest\n        .spyOn(model, 'create')\n        .mockImplementationOnce(() => Promise.resolve(mockUser));\n\n      jest.spyOn(jwtService, 'sign').mockReturnValue('jwtToken');\n\n      const result = await authService.signUp(signUpDto);\n\n      expect(bcrypt.hash).toHaveBeenCalled();\n      expect(result).toEqual({ token });\n    });\n\n    it('should throw duplicate email entered', async () => {\n      jest\n        .spyOn(model, 'create')\n        .mockImplementationOnce(() => Promise.reject({ code: 11000 }));\n\n      await expect(authService.signUp(signUpDto)).rejects.toThrow(\n        ConflictException,\n      );\n    });\n  });\n\n  describe('logIn', () => {\n    const loginDto = {\n      email: 'ghulam1@gmail.com',\n      password: '12345678',\n    };\n\n    it('should login user and return the token', async () => {\n      jest.spyOn(model, 'findOne').mockResolvedValueOnce(mockUser);\n\n      jest.spyOn(bcrypt, 'compare').mockResolvedValueOnce(true);\n      jest.spyOn(jwtService, 'sign').mockReturnValue(token);\n\n      const result = await authService.login(loginDto);\n\n      expect(result).toEqual({ token });\n    });\n\n    it('should throw invalid email error', async () => {\n      jest.spyOn(model, 'findOne').mockResolvedValueOnce(null);\n\n      expect(authService.login(loginDto)).rejects.toThrow(\n        UnauthorizedException,\n      );\n    });\n\n    it('should throw invalid password error', async () => {\n      jest.spyOn(model, 'findOne').mockResolvedValueOnce(mockUser);\n      jest.spyOn(bcrypt, 'compare').mockResolvedValueOnce(false);\n\n      expect(authService.login(loginDto)).rejects.toThrow(\n        UnauthorizedException,\n      );\n    });\n  });\n});\n"
        }
    ]
}